"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/map/page",{

/***/ "(app-pages-browser)/./services/orderService.ts":
/*!**********************************!*\
  !*** ./services/orderService.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelOrder: function() { return /* binding */ cancelOrder; },\n/* harmony export */   createOrder: function() { return /* binding */ createOrder; },\n/* harmony export */   getDeliveryTracking: function() { return /* binding */ getDeliveryTracking; },\n/* harmony export */   getOrder: function() { return /* binding */ getOrder; },\n/* harmony export */   getOrderStatuses: function() { return /* binding */ getOrderStatuses; },\n/* harmony export */   getOrders: function() { return /* binding */ getOrders; },\n/* harmony export */   getOrdersByStatus: function() { return /* binding */ getOrdersByStatus; },\n/* harmony export */   orderService: function() { return /* binding */ orderService; },\n/* harmony export */   updateOrderStatus: function() { return /* binding */ updateOrderStatus; }\n/* harmony export */ });\n// Mock data for demonstration\nconst mockOrders = [\n    {\n        id: 1,\n        userId: 1,\n        items: [\n            {\n                id: 1,\n                name: \"Margherita Pizza\",\n                description: \"Fresh tomato sauce, mozzarella, and basil\",\n                price: 32000,\n                category: \"Pizza\",\n                image: \"/images/pizza.jpg\",\n                quantity: 1\n            },\n            {\n                id: 2,\n                name: \"Caesar Salad\",\n                description: \"Crispy romaine lettuce with caesar dressing\",\n                price: 12000,\n                category: \"Salad\",\n                image: \"/images/salad.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 44000,\n        status: \"confirmed\",\n        createdAt: new Date(\"2024-01-15T10:30:00\"),\n        updatedAt: new Date(\"2024-01-15T10:35:00\")\n    },\n    {\n        id: 2,\n        userId: 1,\n        items: [\n            {\n                id: 3,\n                name: \"Chicken Burger\",\n                description: \"Grilled chicken breast with lettuce and tomato\",\n                price: 15,\n                category: \"Burger\",\n                image: \"/images/burger.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 15.99,\n        status: \"preparing\",\n        createdAt: new Date(\"2024-01-15T11:00:00\"),\n        updatedAt: new Date(\"2024-01-15T11:05:00\")\n    },\n    {\n        id: 3,\n        userId: 1,\n        items: [\n            {\n                id: 4,\n                name: \"Spaghetti Carbonara\",\n                description: \"Classic Italian pasta with eggs, cheese, and pancetta\",\n                price: 22.99,\n                category: \"Pasta\",\n                image: \"/images/pasta.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 22.99,\n        status: \"out_for_delivery\",\n        createdAt: new Date(\"2024-01-15T09:15:00\"),\n        updatedAt: new Date(\"2024-01-15T11:45:00\")\n    },\n    {\n        id: 4,\n        userId: 1,\n        items: [\n            {\n                id: 5,\n                name: \"Fish and Chips\",\n                description: \"Beer-battered fish with crispy fries\",\n                price: 19.99,\n                category: \"Seafood\",\n                image: \"/images/fish.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 19.99,\n        status: \"delivered\",\n        createdAt: new Date(\"2024-01-14T18:30:00\"),\n        updatedAt: new Date(\"2024-01-14T19:15:00\")\n    }\n];\nconst mockDeliveryTracking = {\n    1: {\n        orderId: 1,\n        status: \"confirmed\",\n        estimatedDeliveryTime: new Date(Date.now() + 45 * 60 * 1000),\n        currentLocation: {\n            lat: 35.228950619029085,\n            lng: 126.8427269951037\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Sarah Johnson\",\n            phone: \"+82-10-1234-5678\",\n            department: \"Kitchen Operations\",\n            role: \"Kitchen Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T10:30:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T10:35:00\"),\n                status: \"Order confirmed\",\n                location: \"Restaurant Kitchen\"\n            }\n        ]\n    },\n    2: {\n        orderId: 2,\n        status: \"preparing\",\n        estimatedDeliveryTime: new Date(Date.now() + 35 * 60 * 1000),\n        currentLocation: {\n            lat: 35.228950619029085,\n            lng: 126.8427269951037\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Mike Chen\",\n            phone: \"+82-10-2345-6789\",\n            department: \"Food Preparation\",\n            role: \"Head Chef\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T11:00:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T11:05:00\"),\n                status: \"Preparing your order\",\n                location: \"Restaurant Kitchen\"\n            }\n        ]\n    },\n    3: {\n        orderId: 3,\n        status: \"out_for_delivery\",\n        estimatedDeliveryTime: new Date(Date.now() + 15 * 60 * 1000),\n        currentLocation: {\n            lat: 35.2290,\n            lng: 126.8420\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Emma Davis\",\n            phone: \"+82-10-3456-7890\",\n            department: \"Delivery Operations\",\n            role: \"Delivery Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T09:15:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T09:30:00\"),\n                status: \"Order prepared\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T11:45:00\"),\n                status: \"Out for delivery\",\n                location: \"En route to customer\"\n            }\n        ]\n    },\n    4: {\n        orderId: 4,\n        status: \"delivered\",\n        estimatedDeliveryTime: new Date(\"2024-01-14T19:15:00\"),\n        currentLocation: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"James Wilson\",\n            phone: \"+82-10-4567-8901\",\n            department: \"Customer Service\",\n            role: \"Service Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-14T18:30:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T18:45:00\"),\n                status: \"Order prepared\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T19:00:00\"),\n                status: \"Out for delivery\",\n                location: \"En route to customer\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T19:15:00\"),\n                status: \"Delivered successfully\",\n                location: \"Customer location\"\n            }\n        ]\n    }\n};\n// Simulate API delay\nconst delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n// Helper function to ensure order has proper structure\nconst normalizeOrder = (order)=>{\n    return {\n        id: order.id || 0,\n        userId: order.userId || 0,\n        items: Array.isArray(order.items) ? order.items.map((item)=>({\n                id: item.id || 0,\n                name: item.name || \"Unknown Item\",\n                description: item.description || \"\",\n                price: typeof item.price === \"number\" ? item.price : 0,\n                category: item.category || \"Unknown\",\n                image: item.image || \"\",\n                quantity: typeof item.quantity === \"number\" ? item.quantity : 1\n            })) : [],\n        totalAmount: typeof order.totalAmount === \"number\" ? order.totalAmount : 0,\n        status: order.status || \"pending\",\n        createdAt: order.createdAt ? new Date(order.createdAt) : new Date(),\n        updatedAt: order.updatedAt ? new Date(order.updatedAt) : new Date()\n    };\n};\nconst orderService = {\n    // Get all orders for a user\n    async getOrders (userId) {\n        await delay(500); // Simulate API call delay\n        try {\n            let filteredOrders = mockOrders;\n            if (userId) {\n                filteredOrders = mockOrders.filter((order)=>order.userId === userId);\n            }\n            // Normalize all orders to ensure proper structure\n            return filteredOrders.map(normalizeOrder);\n        } catch (error) {\n            console.error(\"Error in getOrders:\", error);\n            return [];\n        }\n    },\n    // Get a specific order by ID\n    async getOrder (orderId) {\n        await delay(300);\n        try {\n            const order = mockOrders.find((order)=>order.id === orderId);\n            return order ? normalizeOrder(order) : null;\n        } catch (error) {\n            console.error(\"Error in getOrder:\", error);\n            return null;\n        }\n    },\n    // Get delivery tracking information for an order\n    async getDeliveryTracking (orderId) {\n        await delay(400);\n        try {\n            const tracking = mockDeliveryTracking[orderId];\n            return tracking || null;\n        } catch (error) {\n            console.error(\"Error in getDeliveryTracking:\", error);\n            return null;\n        }\n    },\n    // Create a new order\n    async createOrder (orderData) {\n        await delay(600);\n        try {\n            const newOrder = normalizeOrder({\n                ...orderData,\n                id: mockOrders.length + 1,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n            mockOrders.push(newOrder);\n            // Create initial delivery tracking\n            mockDeliveryTracking[newOrder.id] = {\n                orderId: newOrder.id,\n                status: \"confirmed\",\n                estimatedDeliveryTime: new Date(Date.now() + 45 * 60 * 1000),\n                currentLocation: {\n                    lat: 35.228950619029085,\n                    lng: 126.8427269951037\n                },\n                destination: {\n                    lat: 35.22858702880908,\n                    lng: 126.83922370972543\n                },\n                managerInfo: {\n                    name: \"New Order Manager\",\n                    phone: \"+82-10-9999-0000\",\n                    department: \"Order Processing\",\n                    role: \"Order Manager\"\n                },\n                updates: [\n                    {\n                        timestamp: new Date(),\n                        status: \"Order received\",\n                        location: \"Restaurant Kitchen\"\n                    }\n                ]\n            };\n            return newOrder;\n        } catch (error) {\n            console.error(\"Error in createOrder:\", error);\n            throw new Error(\"Failed to create order\");\n        }\n    },\n    // Update order status\n    async updateOrderStatus (orderId, status) {\n        await delay(300);\n        try {\n            const orderIndex = mockOrders.findIndex((order)=>order.id === orderId);\n            if (orderIndex === -1) return null;\n            mockOrders[orderIndex].status = status;\n            mockOrders[orderIndex].updatedAt = new Date();\n            // Update delivery tracking\n            if (mockDeliveryTracking[orderId]) {\n                mockDeliveryTracking[orderId].status = status;\n                mockDeliveryTracking[orderId].updates.push({\n                    timestamp: new Date(),\n                    status: \"Status updated to \".concat(status),\n                    location: status === \"delivered\" ? \"Customer location\" : \"In progress\"\n                });\n            }\n            return normalizeOrder(mockOrders[orderIndex]);\n        } catch (error) {\n            console.error(\"Error in updateOrderStatus:\", error);\n            return null;\n        }\n    },\n    // Cancel an order\n    async cancelOrder (orderId) {\n        await delay(400);\n        try {\n            const orderIndex = mockOrders.findIndex((order)=>order.id === orderId);\n            if (orderIndex === -1) return false;\n            if (mockOrders[orderIndex].status === \"delivered\") {\n                return false; // Cannot cancel delivered orders\n            }\n            mockOrders[orderIndex].status = \"cancelled\";\n            mockOrders[orderIndex].updatedAt = new Date();\n            // Update delivery tracking\n            if (mockDeliveryTracking[orderId]) {\n                mockDeliveryTracking[orderId].status = \"cancelled\";\n                mockDeliveryTracking[orderId].updates.push({\n                    timestamp: new Date(),\n                    status: \"Order cancelled\",\n                    location: \"Restaurant\"\n                });\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in cancelOrder:\", error);\n            return false;\n        }\n    },\n    // Get order status options\n    getOrderStatuses () {\n        return [\n            \"pending\",\n            \"confirmed\",\n            \"preparing\",\n            \"ready_for_pickup\",\n            \"out_for_delivery\",\n            \"delivered\",\n            \"cancelled\"\n        ];\n    },\n    // Search orders by status\n    async getOrdersByStatus (status, userId) {\n        await delay(300);\n        try {\n            let filteredOrders = mockOrders.filter((order)=>order.status === status);\n            if (userId) {\n                filteredOrders = filteredOrders.filter((order)=>order.userId === userId);\n            }\n            return filteredOrders.map(normalizeOrder);\n        } catch (error) {\n            console.error(\"Error in getOrdersByStatus:\", error);\n            return [];\n        }\n    }\n};\n// Export individual functions for named imports\nconst { getOrders, getOrder, getDeliveryTracking, createOrder, updateOrderStatus, cancelOrder, getOrderStatuses, getOrdersByStatus } = orderService;\n// Default export\n/* harmony default export */ __webpack_exports__[\"default\"] = (orderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29yZGVyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFQSw4QkFBOEI7QUFDOUIsTUFBTUEsYUFBc0I7SUFDeEI7UUFDSUMsSUFBSTtRQUNKQyxRQUFRO1FBQ1JDLE9BQU87WUFDSDtnQkFDSUYsSUFBSTtnQkFDSkcsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsT0FBTztnQkFDUEMsVUFBVTtnQkFDVkMsT0FBTztnQkFDUEMsVUFBVTtZQUNkO1lBQ0E7Z0JBQ0lSLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElB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TTtRQUVaLElBQUk7WUFDQSxJQUFJYSxpQkFBaUIzQyxXQUFXNEMsTUFBTSxDQUFDUixDQUFBQSxRQUFTQSxNQUFNekIsTUFBTSxLQUFLQTtZQUVqRSxJQUFJVCxRQUFRO2dCQUNSeUMsaUJBQWlCQSxlQUFlQyxNQUFNLENBQUNSLENBQUFBLFFBQVNBLE1BQU1sQyxNQUFNLEtBQUtBO1lBQ3JFO1lBRUEsT0FBT3lDLGVBQWVKLEdBQUcsQ0FBQ0o7UUFDOUIsRUFBRSxPQUFPVSxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU8sRUFBRTtRQUNiO0lBQ0o7QUFDSixFQUFFO0FBRUYsZ0RBQWdEO0FBQ3pDLE1BQU0sRUFDVEgsU0FBUyxFQUNUSyxRQUFRLEVBQ1JFLG1CQUFtQixFQUNuQkUsV0FBVyxFQUNYTSxpQkFBaUIsRUFDakJHLFdBQVcsRUFDWEMsZ0JBQWdCLEVBQ2hCQyxpQkFBaUIsRUFDcEIsR0FBR3JCLGFBQWE7QUFFakIsaUJBQWlCO0FBQ2pCLCtEQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NlcnZpY2VzL29yZGVyU2VydmljZS50cz85MDZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9yZGVyLCBEZWxpdmVyeVRyYWNraW5nLCBPcmRlckl0ZW0gfSBmcm9tICcuLi90eXBlcy9vcmRlcic7XG5cbi8vIE1vY2sgZGF0YSBmb3IgZGVtb25zdHJhdGlvblxuY29uc3QgbW9ja09yZGVyczogT3JkZXJbXSA9IFtcbiAgICB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJNYXJnaGVyaXRhIFBpenphXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiRnJlc2ggdG9tYXRvIHNhdWNlLCBtb3p6YXJlbGxhLCBhbmQgYmFzaWxcIixcbiAgICAgICAgICAgICAgICBwcmljZTogMzIwMDAsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IFwiUGl6emFcIixcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BpenphLmpwZ1wiLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ2Flc2FyIFNhbGFkXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQ3Jpc3B5IHJvbWFpbmUgbGV0dHVjZSB3aXRoIGNhZXNhciBkcmVzc2luZ1wiLFxuICAgICAgICAgICAgICAgIHByaWNlOiAxMjAwMCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogXCJTYWxhZFwiLFxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvc2FsYWQuanBnXCIsXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG90YWxBbW91bnQ6IDQ0MDAwLFxuICAgICAgICBzdGF0dXM6IFwiY29uZmlybWVkXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzA6MDAnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMDozNTowMCcpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAyLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJDaGlja2VuIEJ1cmdlclwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkdyaWxsZWQgY2hpY2tlbiBicmVhc3Qgd2l0aCBsZXR0dWNlIGFuZCB0b21hdG9cIixcbiAgICAgICAgICAgICAgICBwcmljZTogMTUsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IFwiQnVyZ2VyXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9idXJnZXIuanBnXCIsXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG90YWxBbW91bnQ6IDE1Ljk5LFxuICAgICAgICBzdGF0dXM6IFwicHJlcGFyaW5nXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTE6MDA6MDAnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMTowNTowMCcpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAzLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJTcGFnaGV0dGkgQ2FyYm9uYXJhXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQ2xhc3NpYyBJdGFsaWFuIHBhc3RhIHdpdGggZWdncywgY2hlZXNlLCBhbmQgcGFuY2V0dGFcIixcbiAgICAgICAgICAgICAgICBwcmljZTogMjIuOTksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IFwiUGFzdGFcIixcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3Bhc3RhLmpwZ1wiLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRvdGFsQW1vdW50OiAyMi45OSxcbiAgICAgICAgc3RhdHVzOiBcIm91dF9mb3JfZGVsaXZlcnlcIixcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQwOToxNTowMCcpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDExOjQ1OjAwJylcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IDQsXG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkZpc2ggYW5kIENoaXBzXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQmVlci1iYXR0ZXJlZCBmaXNoIHdpdGggY3Jpc3B5IGZyaWVzXCIsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDE5Ljk5LFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBcIlNlYWZvb2RcIixcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL2Zpc2guanBnXCIsXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG90YWxBbW91bnQ6IDE5Ljk5LFxuICAgICAgICBzdGF0dXM6IFwiZGVsaXZlcmVkXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTg6MzA6MDAnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNFQxOToxNTowMCcpXG4gICAgfVxuXTtcblxuY29uc3QgbW9ja0RlbGl2ZXJ5VHJhY2tpbmc6IFJlY29yZDxudW1iZXIsIERlbGl2ZXJ5VHJhY2tpbmc+ID0ge1xuICAgIDE6IHtcbiAgICAgICAgb3JkZXJJZDogMSxcbiAgICAgICAgc3RhdHVzOiBcImNvbmZpcm1lZFwiLFxuICAgICAgICBlc3RpbWF0ZWREZWxpdmVyeVRpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgKyA0NSAqIDYwICogMTAwMCksIC8vIDQ1IG1pbnV0ZXMgZnJvbSBub3dcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgICBsYXQ6IDM1LjIyODk1MDYxOTAyOTA4NSxcbiAgICAgICAgICAgIGxuZzogMTI2Ljg0MjcyNjk5NTEwMzdcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4NTg3MDI4ODA5MDgsXG4gICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICB9LFxuICAgICAgICBtYW5hZ2VySW5mbzoge1xuICAgICAgICAgICAgbmFtZTogXCJTYXJhaCBKb2huc29uXCIsXG4gICAgICAgICAgICBwaG9uZTogXCIrODItMTAtMTIzNC01Njc4XCIsXG4gICAgICAgICAgICBkZXBhcnRtZW50OiBcIktpdGNoZW4gT3BlcmF0aW9uc1wiLFxuICAgICAgICAgICAgcm9sZTogXCJLaXRjaGVuIE1hbmFnZXJcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMDozMDowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciByZWNlaXZlZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgY29uZmlybWVkXCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudCBLaXRjaGVuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgMjoge1xuICAgICAgICBvcmRlcklkOiAyLFxuICAgICAgICBzdGF0dXM6IFwicHJlcGFyaW5nXCIsXG4gICAgICAgIGVzdGltYXRlZERlbGl2ZXJ5VGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM1ICogNjAgKiAxMDAwKSwgLy8gMzUgbWludXRlcyBmcm9tIG5vd1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4OTUwNjE5MDI5MDg1LFxuICAgICAgICAgICAgbG5nOiAxMjYuODQyNzI2OTk1MTAzN1xuICAgICAgICB9LFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgbGF0OiAzNS4yMjg1ODcwMjg4MDkwOCxcbiAgICAgICAgICAgIGxuZzogMTI2LjgzOTIyMzcwOTcyNTQzXG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZXJJbmZvOiB7XG4gICAgICAgICAgICBuYW1lOiBcIk1pa2UgQ2hlblwiLFxuICAgICAgICAgICAgcGhvbmU6IFwiKzgyLTEwLTIzNDUtNjc4OVwiLFxuICAgICAgICAgICAgZGVwYXJ0bWVudDogXCJGb29kIFByZXBhcmF0aW9uXCIsXG4gICAgICAgICAgICByb2xlOiBcIkhlYWQgQ2hlZlwiXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDExOjAwOjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIHJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudCBLaXRjaGVuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMTowNTowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJQcmVwYXJpbmcgeW91ciBvcmRlclwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIDM6IHtcbiAgICAgICAgb3JkZXJJZDogMyxcbiAgICAgICAgc3RhdHVzOiBcIm91dF9mb3JfZGVsaXZlcnlcIixcbiAgICAgICAgZXN0aW1hdGVkRGVsaXZlcnlUaW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTUgKiA2MCAqIDEwMDApLCAvLyAxNSBtaW51dGVzIGZyb20gbm93XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgICAgbGF0OiAzNS4yMjkwLFxuICAgICAgICAgICAgbG5nOiAxMjYuODQyMFxuICAgICAgICB9LFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgbGF0OiAzNS4yMjg1ODcwMjg4MDkwOCxcbiAgICAgICAgICAgIGxuZzogMTI2LjgzOTIyMzcwOTcyNTQzXG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZXJJbmZvOiB7XG4gICAgICAgICAgICBuYW1lOiBcIkVtbWEgRGF2aXNcIixcbiAgICAgICAgICAgIHBob25lOiBcIis4Mi0xMC0zNDU2LTc4OTBcIixcbiAgICAgICAgICAgIGRlcGFydG1lbnQ6IFwiRGVsaXZlcnkgT3BlcmF0aW9uc1wiLFxuICAgICAgICAgICAgcm9sZTogXCJEZWxpdmVyeSBNYW5hZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMDk6MTU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgcmVjZWl2ZWRcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJSZXN0YXVyYW50IEtpdGNoZW5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDA5OjMwOjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIHByZXBhcmVkXCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudCBLaXRjaGVuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMTo0NTowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPdXQgZm9yIGRlbGl2ZXJ5XCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiRW4gcm91dGUgdG8gY3VzdG9tZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICA0OiB7XG4gICAgICAgIG9yZGVySWQ6IDQsXG4gICAgICAgIHN0YXR1czogXCJkZWxpdmVyZWRcIixcbiAgICAgICAgZXN0aW1hdGVkRGVsaXZlcnlUaW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNFQxOToxNTowMCcpLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4NTg3MDI4ODA5MDgsXG4gICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICB9LFxuICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgbGF0OiAzNS4yMjg1ODcwMjg4MDkwOCxcbiAgICAgICAgICAgIGxuZzogMTI2LjgzOTIyMzcwOTcyNTQzXG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZXJJbmZvOiB7XG4gICAgICAgICAgICBuYW1lOiBcIkphbWVzIFdpbHNvblwiLFxuICAgICAgICAgICAgcGhvbmU6IFwiKzgyLTEwLTQ1NjctODkwMVwiLFxuICAgICAgICAgICAgZGVwYXJ0bWVudDogXCJDdXN0b21lciBTZXJ2aWNlXCIsXG4gICAgICAgICAgICByb2xlOiBcIlNlcnZpY2UgTWFuYWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE0VDE4OjMwOjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIHJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudCBLaXRjaGVuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNFQxODo0NTowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciBwcmVwYXJlZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTk6MDA6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3V0IGZvciBkZWxpdmVyeVwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIkVuIHJvdXRlIHRvIGN1c3RvbWVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNFQxOToxNTowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJEZWxpdmVyZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiQ3VzdG9tZXIgbG9jYXRpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxufTtcblxuLy8gU2ltdWxhdGUgQVBJIGRlbGF5XG5jb25zdCBkZWxheSA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGVuc3VyZSBvcmRlciBoYXMgcHJvcGVyIHN0cnVjdHVyZVxuY29uc3Qgbm9ybWFsaXplT3JkZXIgPSAob3JkZXI6IGFueSk6IE9yZGVyID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogb3JkZXIuaWQgfHwgMCxcbiAgICAgICAgdXNlcklkOiBvcmRlci51c2VySWQgfHwgMCxcbiAgICAgICAgaXRlbXM6IEFycmF5LmlzQXJyYXkob3JkZXIuaXRlbXMpID8gb3JkZXIuaXRlbXMubWFwKChpdGVtOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCB8fCAwLFxuICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lIHx8ICdVbmtub3duIEl0ZW0nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICBwcmljZTogdHlwZW9mIGl0ZW0ucHJpY2UgPT09ICdudW1iZXInID8gaXRlbS5wcmljZSA6IDAsXG4gICAgICAgICAgICBjYXRlZ29yeTogaXRlbS5jYXRlZ29yeSB8fCAnVW5rbm93bicsXG4gICAgICAgICAgICBpbWFnZTogaXRlbS5pbWFnZSB8fCAnJyxcbiAgICAgICAgICAgIHF1YW50aXR5OiB0eXBlb2YgaXRlbS5xdWFudGl0eSA9PT0gJ251bWJlcicgPyBpdGVtLnF1YW50aXR5IDogMVxuICAgICAgICB9KSkgOiBbXSxcbiAgICAgICAgdG90YWxBbW91bnQ6IHR5cGVvZiBvcmRlci50b3RhbEFtb3VudCA9PT0gJ251bWJlcicgPyBvcmRlci50b3RhbEFtb3VudCA6IDAsXG4gICAgICAgIHN0YXR1czogb3JkZXIuc3RhdHVzIHx8ICdwZW5kaW5nJyxcbiAgICAgICAgY3JlYXRlZEF0OiBvcmRlci5jcmVhdGVkQXQgPyBuZXcgRGF0ZShvcmRlci5jcmVhdGVkQXQpIDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBvcmRlci51cGRhdGVkQXQgPyBuZXcgRGF0ZShvcmRlci51cGRhdGVkQXQpIDogbmV3IERhdGUoKVxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3Qgb3JkZXJTZXJ2aWNlID0ge1xuICAgIC8vIEdldCBhbGwgb3JkZXJzIGZvciBhIHVzZXJcbiAgICBhc3luYyBnZXRPcmRlcnModXNlcklkPzogbnVtYmVyKTogUHJvbWlzZTxPcmRlcltdPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDUwMCk7IC8vIFNpbXVsYXRlIEFQSSBjYWxsIGRlbGF5XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkT3JkZXJzID0gbW9ja09yZGVycztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkT3JkZXJzID0gbW9ja09yZGVycy5maWx0ZXIob3JkZXIgPT4gb3JkZXIudXNlcklkID09PSB1c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYWxsIG9yZGVycyB0byBlbnN1cmUgcHJvcGVyIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkT3JkZXJzLm1hcChub3JtYWxpemVPcmRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRPcmRlcnM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhIHNwZWNpZmljIG9yZGVyIGJ5IElEXG4gICAgYXN5bmMgZ2V0T3JkZXIob3JkZXJJZDogbnVtYmVyKTogUHJvbWlzZTxPcmRlciB8IG51bGw+IHtcbiAgICAgICAgYXdhaXQgZGVsYXkoMzAwKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IG1vY2tPcmRlcnMuZmluZChvcmRlciA9PiBvcmRlci5pZCA9PT0gb3JkZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gb3JkZXIgPyBub3JtYWxpemVPcmRlcihvcmRlcikgOiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0T3JkZXI6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGRlbGl2ZXJ5IHRyYWNraW5nIGluZm9ybWF0aW9uIGZvciBhbiBvcmRlclxuICAgIGFzeW5jIGdldERlbGl2ZXJ5VHJhY2tpbmcob3JkZXJJZDogbnVtYmVyKTogUHJvbWlzZTxEZWxpdmVyeVRyYWNraW5nIHwgbnVsbD4ge1xuICAgICAgICBhd2FpdCBkZWxheSg0MDApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nID0gbW9ja0RlbGl2ZXJ5VHJhY2tpbmdbb3JkZXJJZF07XG4gICAgICAgICAgICByZXR1cm4gdHJhY2tpbmcgfHwgbnVsbDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldERlbGl2ZXJ5VHJhY2tpbmc6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG9yZGVyXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIob3JkZXJEYXRhOiBPbWl0PE9yZGVyLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4pOiBQcm9taXNlPE9yZGVyPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDYwMCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3T3JkZXI6IE9yZGVyID0gbm9ybWFsaXplT3JkZXIoe1xuICAgICAgICAgICAgICAgIC4uLm9yZGVyRGF0YSxcbiAgICAgICAgICAgICAgICBpZDogbW9ja09yZGVycy5sZW5ndGggKyAxLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrT3JkZXJzLnB1c2gobmV3T3JkZXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBkZWxpdmVyeSB0cmFja2luZ1xuICAgICAgICAgICAgbW9ja0RlbGl2ZXJ5VHJhY2tpbmdbbmV3T3JkZXIuaWRdID0ge1xuICAgICAgICAgICAgICAgIG9yZGVySWQ6IG5ld09yZGVyLmlkLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJjb25maXJtZWRcIixcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWREZWxpdmVyeVRpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgKyA0NSAqIDYwICogMTAwMCksXG4gICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhdDogMzUuMjI4OTUwNjE5MDI5MDg1LFxuICAgICAgICAgICAgICAgICAgICBsbmc6IDEyNi44NDI3MjY5OTUxMDM3XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBsYXQ6IDM1LjIyODU4NzAyODgwOTA4LFxuICAgICAgICAgICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWFuYWdlckluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJOZXcgT3JkZXIgTWFuYWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBwaG9uZTogXCIrODItMTAtOTk5OS0wMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlcGFydG1lbnQ6IFwiT3JkZXIgUHJvY2Vzc2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcIk9yZGVyIE1hbmFnZXJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgcmVjZWl2ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gbmV3T3JkZXI7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjcmVhdGVPcmRlcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgb3JkZXInKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgb3JkZXIgc3RhdHVzXG4gICAgYXN5bmMgdXBkYXRlT3JkZXJTdGF0dXMob3JkZXJJZDogbnVtYmVyLCBzdGF0dXM6IHN0cmluZyk6IFByb21pc2U8T3JkZXIgfCBudWxsPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDMwMCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJJbmRleCA9IG1vY2tPcmRlcnMuZmluZEluZGV4KG9yZGVyID0+IG9yZGVyLmlkID09PSBvcmRlcklkKTtcbiAgICAgICAgICAgIGlmIChvcmRlckluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tPcmRlcnNbb3JkZXJJbmRleF0uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgbW9ja09yZGVyc1tvcmRlckluZGV4XS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgZGVsaXZlcnkgdHJhY2tpbmdcbiAgICAgICAgICAgIGlmIChtb2NrRGVsaXZlcnlUcmFja2luZ1tvcmRlcklkXSkge1xuICAgICAgICAgICAgICAgIG1vY2tEZWxpdmVyeVRyYWNraW5nW29yZGVySWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICBtb2NrRGVsaXZlcnlUcmFja2luZ1tvcmRlcklkXS51cGRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogYFN0YXR1cyB1cGRhdGVkIHRvICR7c3RhdHVzfWAsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBzdGF0dXMgPT09IFwiZGVsaXZlcmVkXCIgPyBcIkN1c3RvbWVyIGxvY2F0aW9uXCIgOiBcIkluIHByb2dyZXNzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU9yZGVyKG1vY2tPcmRlcnNbb3JkZXJJbmRleF0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlT3JkZXJTdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2FuY2VsIGFuIG9yZGVyXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIob3JkZXJJZDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDQwMCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJJbmRleCA9IG1vY2tPcmRlcnMuZmluZEluZGV4KG9yZGVyID0+IG9yZGVyLmlkID09PSBvcmRlcklkKTtcbiAgICAgICAgICAgIGlmIChvcmRlckluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobW9ja09yZGVyc1tvcmRlckluZGV4XS5zdGF0dXMgPT09IFwiZGVsaXZlcmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIENhbm5vdCBjYW5jZWwgZGVsaXZlcmVkIG9yZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrT3JkZXJzW29yZGVySW5kZXhdLnN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICBtb2NrT3JkZXJzW29yZGVySW5kZXhdLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkZWxpdmVyeSB0cmFja2luZ1xuICAgICAgICAgICAgaWYgKG1vY2tEZWxpdmVyeVRyYWNraW5nW29yZGVySWRdKSB7XG4gICAgICAgICAgICAgICAgbW9ja0RlbGl2ZXJ5VHJhY2tpbmdbb3JkZXJJZF0uc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICBtb2NrRGVsaXZlcnlUcmFja2luZ1tvcmRlcklkXS51cGRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciBjYW5jZWxsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY2FuY2VsT3JkZXI6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBvcmRlciBzdGF0dXMgb3B0aW9uc1xuICAgIGdldE9yZGVyU3RhdHVzZXMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICBcImNvbmZpcm1lZFwiLCBcbiAgICAgICAgICAgIFwicHJlcGFyaW5nXCIsXG4gICAgICAgICAgICBcInJlYWR5X2Zvcl9waWNrdXBcIixcbiAgICAgICAgICAgIFwib3V0X2Zvcl9kZWxpdmVyeVwiLFxuICAgICAgICAgICAgXCJkZWxpdmVyZWRcIixcbiAgICAgICAgICAgIFwiY2FuY2VsbGVkXCJcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy8gU2VhcmNoIG9yZGVycyBieSBzdGF0dXNcbiAgICBhc3luYyBnZXRPcmRlcnNCeVN0YXR1cyhzdGF0dXM6IHN0cmluZywgdXNlcklkPzogbnVtYmVyKTogUHJvbWlzZTxPcmRlcltdPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDMwMCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkT3JkZXJzID0gbW9ja09yZGVycy5maWx0ZXIob3JkZXIgPT4gb3JkZXIuc3RhdHVzID09PSBzdGF0dXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodXNlcklkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRPcmRlcnMgPSBmaWx0ZXJlZE9yZGVycy5maWx0ZXIob3JkZXIgPT4gb3JkZXIudXNlcklkID09PSB1c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRPcmRlcnMubWFwKG5vcm1hbGl6ZU9yZGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldE9yZGVyc0J5U3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEV4cG9ydCBpbmRpdmlkdWFsIGZ1bmN0aW9ucyBmb3IgbmFtZWQgaW1wb3J0c1xuZXhwb3J0IGNvbnN0IHtcbiAgICBnZXRPcmRlcnMsXG4gICAgZ2V0T3JkZXIsXG4gICAgZ2V0RGVsaXZlcnlUcmFja2luZyxcbiAgICBjcmVhdGVPcmRlcixcbiAgICB1cGRhdGVPcmRlclN0YXR1cyxcbiAgICBjYW5jZWxPcmRlcixcbiAgICBnZXRPcmRlclN0YXR1c2VzLFxuICAgIGdldE9yZGVyc0J5U3RhdHVzXG59ID0gb3JkZXJTZXJ2aWNlO1xuXG4vLyBEZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgb3JkZXJTZXJ2aWNlO1xuIl0sIm5hbWVzIjpbIm1vY2tPcmRlcnMiLCJpZCIsInVzZXJJZCIsIml0ZW1zIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJjYXRlZ29yeSIsImltYWdlIiwicXVhbnRpdHkiLCJ0b3RhbEFtb3VudCIsInN0YXR1cyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1cGRhdGVkQXQiLCJtb2NrRGVsaXZlcnlUcmFja2luZyIsIm9yZGVySWQiLCJlc3RpbWF0ZWREZWxpdmVyeVRpbWUiLCJub3ciLCJjdXJyZW50TG9jYXRpb24iLCJsYXQiLCJsbmciLCJkZXN0aW5hdGlvbiIsIm1hbmFnZXJJbmZvIiwicGhvbmUiLCJkZXBhcnRtZW50Iiwicm9sZSIsInVwZGF0ZXMiLCJ0aW1lc3RhbXAiLCJsb2NhdGlvbiIsImRlbGF5IiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJub3JtYWxpemVPcmRlciIsIm9yZGVyIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiaXRlbSIsIm9yZGVyU2VydmljZSIsImdldE9yZGVycyIsImZpbHRlcmVkT3JkZXJzIiwiZmlsdGVyIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0T3JkZXIiLCJmaW5kIiwiZ2V0RGVsaXZlcnlUcmFja2luZyIsInRyYWNraW5nIiwiY3JlYXRlT3JkZXIiLCJvcmRlckRhdGEiLCJuZXdPcmRlciIsImxlbmd0aCIsInB1c2giLCJFcnJvciIsInVwZGF0ZU9yZGVyU3RhdHVzIiwib3JkZXJJbmRleCIsImZpbmRJbmRleCIsImNhbmNlbE9yZGVyIiwiZ2V0T3JkZXJTdGF0dXNlcyIsImdldE9yZGVyc0J5U3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/orderService.ts\n"));

/***/ })

});