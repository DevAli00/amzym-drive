"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/map/page",{

/***/ "(app-pages-browser)/./services/orderService.ts":
/*!**********************************!*\
  !*** ./services/orderService.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelOrder: function() { return /* binding */ cancelOrder; },\n/* harmony export */   createOrder: function() { return /* binding */ createOrder; },\n/* harmony export */   getDeliveryTracking: function() { return /* binding */ getDeliveryTracking; },\n/* harmony export */   getOrder: function() { return /* binding */ getOrder; },\n/* harmony export */   getOrderStatuses: function() { return /* binding */ getOrderStatuses; },\n/* harmony export */   getOrders: function() { return /* binding */ getOrders; },\n/* harmony export */   getOrdersByStatus: function() { return /* binding */ getOrdersByStatus; },\n/* harmony export */   orderService: function() { return /* binding */ orderService; },\n/* harmony export */   updateOrderStatus: function() { return /* binding */ updateOrderStatus; }\n/* harmony export */ });\n// Mock data for demonstration\nconst mockOrders = [\n    {\n        id: 1,\n        userId: 1,\n        items: [\n            {\n                id: 1,\n                name: \"Margherita Pizza\",\n                description: \"Fresh tomato sauce, mozzarella, and basil\",\n                price: 32000,\n                category: \"Pizza\",\n                image: \"/images/pizza.jpg\",\n                quantity: 1\n            },\n            {\n                id: 2,\n                name: \"Caesar Salad\",\n                description: \"Crispy romaine lettuce with caesar dressing\",\n                price: 12000,\n                category: \"Salad\",\n                image: \"/images/salad.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 44000,\n        status: \"confirmed\",\n        createdAt: new Date(\"2024-01-15T10:30:00\"),\n        updatedAt: new Date(\"2024-01-15T10:35:00\")\n    },\n    {\n        id: 2,\n        userId: 1,\n        items: [\n            {\n                id: 3,\n                name: \"Chicken Burger\",\n                description: \"Grilled chicken breast with lettuce and tomato\",\n                price: 9000,\n                category: \"Burger\",\n                image: \"/images/burger.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 9000,\n        status: \"preparing\",\n        createdAt: new Date(\"2024-01-15T11:00:00\"),\n        updatedAt: new Date(\"2024-01-15T11:05:00\")\n    },\n    {\n        id: 3,\n        userId: 1,\n        items: [\n            {\n                id: 4,\n                name: \"Spaghetti Carbonara\",\n                description: \"Classic Italian pasta with eggs, cheese, and pancetta\",\n                price: 22.99,\n                category: \"Pasta\",\n                image: \"/images/pasta.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 22.99,\n        status: \"out_for_delivery\",\n        createdAt: new Date(\"2024-01-15T09:15:00\"),\n        updatedAt: new Date(\"2024-01-15T11:45:00\")\n    },\n    {\n        id: 4,\n        userId: 1,\n        items: [\n            {\n                id: 5,\n                name: \"Fish and Chips\",\n                description: \"Beer-battered fish with crispy fries\",\n                price: 19.99,\n                category: \"Seafood\",\n                image: \"/images/fish.jpg\",\n                quantity: 1\n            }\n        ],\n        totalAmount: 19.99,\n        status: \"delivered\",\n        createdAt: new Date(\"2024-01-14T18:30:00\"),\n        updatedAt: new Date(\"2024-01-14T19:15:00\")\n    }\n];\nconst mockDeliveryTracking = {\n    1: {\n        orderId: 1,\n        status: \"confirmed\",\n        estimatedDeliveryTime: new Date(Date.now() + 45 * 60 * 1000),\n        currentLocation: {\n            lat: 35.228950619029085,\n            lng: 126.8427269951037\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Sarah Johnson\",\n            phone: \"+82-10-1234-5678\",\n            department: \"Kitchen Operations\",\n            role: \"Kitchen Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T10:30:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T10:35:00\"),\n                status: \"Order confirmed\",\n                location: \"Restaurant Kitchen\"\n            }\n        ]\n    },\n    2: {\n        orderId: 2,\n        status: \"preparing\",\n        estimatedDeliveryTime: new Date(Date.now() + 35 * 60 * 1000),\n        currentLocation: {\n            lat: 35.228950619029085,\n            lng: 126.8427269951037\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Mike Chen\",\n            phone: \"+82-10-2345-6789\",\n            department: \"Food Preparation\",\n            role: \"Head Chef\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T11:00:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T11:05:00\"),\n                status: \"Preparing your order\",\n                location: \"Restaurant Kitchen\"\n            }\n        ]\n    },\n    3: {\n        orderId: 3,\n        status: \"out_for_delivery\",\n        estimatedDeliveryTime: new Date(Date.now() + 15 * 60 * 1000),\n        currentLocation: {\n            lat: 35.2290,\n            lng: 126.8420\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"Emma Davis\",\n            phone: \"+82-10-3456-7890\",\n            department: \"Delivery Operations\",\n            role: \"Delivery Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-15T09:15:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T09:30:00\"),\n                status: \"Order prepared\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-15T11:45:00\"),\n                status: \"Out for delivery\",\n                location: \"En route to customer\"\n            }\n        ]\n    },\n    4: {\n        orderId: 4,\n        status: \"delivered\",\n        estimatedDeliveryTime: new Date(\"2024-01-14T19:15:00\"),\n        currentLocation: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        destination: {\n            lat: 35.22858702880908,\n            lng: 126.83922370972543\n        },\n        managerInfo: {\n            name: \"James Wilson\",\n            phone: \"+82-10-4567-8901\",\n            department: \"Customer Service\",\n            role: \"Service Manager\"\n        },\n        updates: [\n            {\n                timestamp: new Date(\"2024-01-14T18:30:00\"),\n                status: \"Order received\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T18:45:00\"),\n                status: \"Order prepared\",\n                location: \"Restaurant Kitchen\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T19:00:00\"),\n                status: \"Out for delivery\",\n                location: \"En route to customer\"\n            },\n            {\n                timestamp: new Date(\"2024-01-14T19:15:00\"),\n                status: \"Delivered successfully\",\n                location: \"Customer location\"\n            }\n        ]\n    }\n};\n// Simulate API delay\nconst delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n// Helper function to ensure order has proper structure\nconst normalizeOrder = (order)=>{\n    return {\n        id: order.id || 0,\n        userId: order.userId || 0,\n        items: Array.isArray(order.items) ? order.items.map((item)=>({\n                id: item.id || 0,\n                name: item.name || \"Unknown Item\",\n                description: item.description || \"\",\n                price: typeof item.price === \"number\" ? item.price : 0,\n                category: item.category || \"Unknown\",\n                image: item.image || \"\",\n                quantity: typeof item.quantity === \"number\" ? item.quantity : 1\n            })) : [],\n        totalAmount: typeof order.totalAmount === \"number\" ? order.totalAmount : 0,\n        status: order.status || \"pending\",\n        createdAt: order.createdAt ? new Date(order.createdAt) : new Date(),\n        updatedAt: order.updatedAt ? new Date(order.updatedAt) : new Date()\n    };\n};\nconst orderService = {\n    // Get all orders for a user\n    async getOrders (userId) {\n        await delay(500); // Simulate API call delay\n        try {\n            let filteredOrders = mockOrders;\n            if (userId) {\n                filteredOrders = mockOrders.filter((order)=>order.userId === userId);\n            }\n            // Normalize all orders to ensure proper structure\n            return filteredOrders.map(normalizeOrder);\n        } catch (error) {\n            console.error(\"Error in getOrders:\", error);\n            return [];\n        }\n    },\n    // Get a specific order by ID\n    async getOrder (orderId) {\n        await delay(300);\n        try {\n            const order = mockOrders.find((order)=>order.id === orderId);\n            return order ? normalizeOrder(order) : null;\n        } catch (error) {\n            console.error(\"Error in getOrder:\", error);\n            return null;\n        }\n    },\n    // Get delivery tracking information for an order\n    async getDeliveryTracking (orderId) {\n        await delay(400);\n        try {\n            const tracking = mockDeliveryTracking[orderId];\n            return tracking || null;\n        } catch (error) {\n            console.error(\"Error in getDeliveryTracking:\", error);\n            return null;\n        }\n    },\n    // Create a new order\n    async createOrder (orderData) {\n        await delay(600);\n        try {\n            const newOrder = normalizeOrder({\n                ...orderData,\n                id: mockOrders.length + 1,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n            mockOrders.push(newOrder);\n            // Create initial delivery tracking\n            mockDeliveryTracking[newOrder.id] = {\n                orderId: newOrder.id,\n                status: \"confirmed\",\n                estimatedDeliveryTime: new Date(Date.now() + 45 * 60 * 1000),\n                currentLocation: {\n                    lat: 35.228950619029085,\n                    lng: 126.8427269951037\n                },\n                destination: {\n                    lat: 35.22858702880908,\n                    lng: 126.83922370972543\n                },\n                managerInfo: {\n                    name: \"New Order Manager\",\n                    phone: \"+82-10-9999-0000\",\n                    department: \"Order Processing\",\n                    role: \"Order Manager\"\n                },\n                updates: [\n                    {\n                        timestamp: new Date(),\n                        status: \"Order received\",\n                        location: \"Restaurant Kitchen\"\n                    }\n                ]\n            };\n            return newOrder;\n        } catch (error) {\n            console.error(\"Error in createOrder:\", error);\n            throw new Error(\"Failed to create order\");\n        }\n    },\n    // Update order status\n    async updateOrderStatus (orderId, status) {\n        await delay(300);\n        try {\n            const orderIndex = mockOrders.findIndex((order)=>order.id === orderId);\n            if (orderIndex === -1) return null;\n            mockOrders[orderIndex].status = status;\n            mockOrders[orderIndex].updatedAt = new Date();\n            // Update delivery tracking\n            if (mockDeliveryTracking[orderId]) {\n                mockDeliveryTracking[orderId].status = status;\n                mockDeliveryTracking[orderId].updates.push({\n                    timestamp: new Date(),\n                    status: \"Status updated to \".concat(status),\n                    location: status === \"delivered\" ? \"Customer location\" : \"In progress\"\n                });\n            }\n            return normalizeOrder(mockOrders[orderIndex]);\n        } catch (error) {\n            console.error(\"Error in updateOrderStatus:\", error);\n            return null;\n        }\n    },\n    // Cancel an order\n    async cancelOrder (orderId) {\n        await delay(400);\n        try {\n            const orderIndex = mockOrders.findIndex((order)=>order.id === orderId);\n            if (orderIndex === -1) return false;\n            if (mockOrders[orderIndex].status === \"delivered\") {\n                return false; // Cannot cancel delivered orders\n            }\n            mockOrders[orderIndex].status = \"cancelled\";\n            mockOrders[orderIndex].updatedAt = new Date();\n            // Update delivery tracking\n            if (mockDeliveryTracking[orderId]) {\n                mockDeliveryTracking[orderId].status = \"cancelled\";\n                mockDeliveryTracking[orderId].updates.push({\n                    timestamp: new Date(),\n                    status: \"Order cancelled\",\n                    location: \"Restaurant\"\n                });\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in cancelOrder:\", error);\n            return false;\n        }\n    },\n    // Get order status options\n    getOrderStatuses () {\n        return [\n            \"pending\",\n            \"confirmed\",\n            \"preparing\",\n            \"ready_for_pickup\",\n            \"out_for_delivery\",\n            \"delivered\",\n            \"cancelled\"\n        ];\n    },\n    // Search orders by status\n    async getOrdersByStatus (status, userId) {\n        await delay(300);\n        try {\n            let filteredOrders = mockOrders.filter((order)=>order.status === status);\n            if (userId) {\n                filteredOrders = filteredOrders.filter((order)=>order.userId === userId);\n            }\n            return filteredOrders.map(normalizeOrder);\n        } catch (error) {\n            console.error(\"Error in getOrdersByStatus:\", error);\n            return [];\n        }\n    }\n};\n// Export individual functions for named imports\nconst { getOrders, getOrder, getDeliveryTracking, createOrder, updateOrderStatus, cancelOrder, getOrderStatuses, getOrdersByStatus } = orderService;\n// Default export\n/* harmony default export */ __webpack_exports__[\"default\"] = (orderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29yZGVyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFQSw4QkFBOEI7QUFDOUIsTUFBTUEsYUFBc0I7SUFDeEI7UUFDSUMsSUFBSTtRQUNKQyxRQUFRO1FBQ1JDLE9BQU87WUFDSDtnQkFDSUYsSUFBSTtnQkFDSkcsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsT0FBTztnQkFDUEMsVUFBVTtnQkFDVkMsT0FBTztnQkFDUEMsVUFBVTtZQUNkO1lBQ0E7Z0JBQ0lSLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElBQUk7Z0JBQ0pHLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDZDtTQUNIO1FBQ0RDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxXQUFXLElBQUlDLEtBQUs7UUFDcEJDLFdBQVcsSUFBSUQsS0FBSztJQUN4QjtJQUNBO1FBQ0laLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1lBQ0g7Z0JBQ0lGLElB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TTtRQUVaLElBQUk7WUFDQSxJQUFJYSxpQkFBaUIzQyxXQUFXNEMsTUFBTSxDQUFDUixDQUFBQSxRQUFTQSxNQUFNekIsTUFBTSxLQUFLQTtZQUVqRSxJQUFJVCxRQUFRO2dCQUNSeUMsaUJBQWlCQSxlQUFlQyxNQUFNLENBQUNSLENBQUFBLFFBQVNBLE1BQU1sQyxNQUFNLEtBQUtBO1lBQ3JFO1lBRUEsT0FBT3lDLGVBQWVKLEdBQUcsQ0FBQ0o7UUFDOUIsRUFBRSxPQUFPVSxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU8sRUFBRTtRQUNiO0lBQ0o7QUFDSixFQUFFO0FBRUYsZ0RBQWdEO0FBQ3pDLE1BQU0sRUFDVEgsU0FBUyxFQUNUSyxRQUFRLEVBQ1JFLG1CQUFtQixFQUNuQkUsV0FBVyxFQUNYTSxpQkFBaUIsRUFDakJHLFdBQVcsRUFDWEMsZ0JBQWdCLEVBQ2hCQyxpQkFBaUIsRUFDcEIsR0FBR3JCLGFBQWE7QUFFakIsaUJBQWlCO0FBQ2pCLCtEQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NlcnZpY2VzL29yZGVyU2VydmljZS50cz85MDZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9yZGVyLCBEZWxpdmVyeVRyYWNraW5nLCBPcmRlckl0ZW0gfSBmcm9tICcuLi90eXBlcy9vcmRlcic7XG5cbi8vIE1vY2sgZGF0YSBmb3IgZGVtb25zdHJhdGlvblxuY29uc3QgbW9ja09yZGVyczogT3JkZXJbXSA9IFtcbiAgICB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJNYXJnaGVyaXRhIFBpenphXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiRnJlc2ggdG9tYXRvIHNhdWNlLCBtb3p6YXJlbGxhLCBhbmQgYmFzaWxcIixcbiAgICAgICAgICAgICAgICBwcmljZTogMzIwMDAsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IFwiUGl6emFcIixcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BpenphLmpwZ1wiLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ2Flc2FyIFNhbGFkXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQ3Jpc3B5IHJvbWFpbmUgbGV0dHVjZSB3aXRoIGNhZXNhciBkcmVzc2luZ1wiLFxuICAgICAgICAgICAgICAgIHByaWNlOiAxMjAwMCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogXCJTYWxhZFwiLFxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvc2FsYWQuanBnXCIsXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG90YWxBbW91bnQ6IDQ0MDAwLFxuICAgICAgICBzdGF0dXM6IFwiY29uZmlybWVkXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzA6MDAnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMDozNTowMCcpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAyLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJDaGlja2VuIEJ1cmdlclwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkdyaWxsZWQgY2hpY2tlbiBicmVhc3Qgd2l0aCBsZXR0dWNlIGFuZCB0b21hdG9cIixcbiAgICAgICAgICAgICAgICBwcmljZTogOTAwMCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogXCJCdXJnZXJcIixcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL2J1cmdlci5qcGdcIixcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0b3RhbEFtb3VudDogOTAwMCxcbiAgICAgICAgc3RhdHVzOiBcInByZXBhcmluZ1wiLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDExOjAwOjAwJyksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTE6MDU6MDAnKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogMyxcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiU3BhZ2hldHRpIENhcmJvbmFyYVwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkNsYXNzaWMgSXRhbGlhbiBwYXN0YSB3aXRoIGVnZ3MsIGNoZWVzZSwgYW5kIHBhbmNldHRhXCIsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDIyLjk5LFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBcIlBhc3RhXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXN0YS5qcGdcIixcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0b3RhbEFtb3VudDogMjIuOTksXG4gICAgICAgIHN0YXR1czogXCJvdXRfZm9yX2RlbGl2ZXJ5XCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMDk6MTU6MDAnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMTo0NTowMCcpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiA0LFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDUsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJGaXNoIGFuZCBDaGlwc1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkJlZXItYmF0dGVyZWQgZmlzaCB3aXRoIGNyaXNweSBmcmllc1wiLFxuICAgICAgICAgICAgICAgIHByaWNlOiAxOS45OSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogXCJTZWFmb29kXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9maXNoLmpwZ1wiLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRvdGFsQW1vdW50OiAxOS45OSxcbiAgICAgICAgc3RhdHVzOiBcImRlbGl2ZXJlZFwiLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTE0VDE4OjMwOjAwJyksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTk6MTU6MDAnKVxuICAgIH1cbl07XG5cbmNvbnN0IG1vY2tEZWxpdmVyeVRyYWNraW5nOiBSZWNvcmQ8bnVtYmVyLCBEZWxpdmVyeVRyYWNraW5nPiA9IHtcbiAgICAxOiB7XG4gICAgICAgIG9yZGVySWQ6IDEsXG4gICAgICAgIHN0YXR1czogXCJjb25maXJtZWRcIixcbiAgICAgICAgZXN0aW1hdGVkRGVsaXZlcnlUaW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNDUgKiA2MCAqIDEwMDApLCAvLyA0NSBtaW51dGVzIGZyb20gbm93XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgICAgbGF0OiAzNS4yMjg5NTA2MTkwMjkwODUsXG4gICAgICAgICAgICBsbmc6IDEyNi44NDI3MjY5OTUxMDM3XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgICAgICBsYXQ6IDM1LjIyODU4NzAyODgwOTA4LFxuICAgICAgICAgICAgbG5nOiAxMjYuODM5MjIzNzA5NzI1NDNcbiAgICAgICAgfSxcbiAgICAgICAgbWFuYWdlckluZm86IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU2FyYWggSm9obnNvblwiLFxuICAgICAgICAgICAgcGhvbmU6IFwiKzgyLTEwLTEyMzQtNTY3OFwiLFxuICAgICAgICAgICAgZGVwYXJ0bWVudDogXCJLaXRjaGVuIE9wZXJhdGlvbnNcIixcbiAgICAgICAgICAgIHJvbGU6IFwiS2l0Y2hlbiBNYW5hZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTA6MzA6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgcmVjZWl2ZWRcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJSZXN0YXVyYW50IEtpdGNoZW5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDEwOjM1OjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIGNvbmZpcm1lZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIDI6IHtcbiAgICAgICAgb3JkZXJJZDogMixcbiAgICAgICAgc3RhdHVzOiBcInByZXBhcmluZ1wiLFxuICAgICAgICBlc3RpbWF0ZWREZWxpdmVyeVRpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzNSAqIDYwICogMTAwMCksIC8vIDM1IG1pbnV0ZXMgZnJvbSBub3dcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgICBsYXQ6IDM1LjIyODk1MDYxOTAyOTA4NSxcbiAgICAgICAgICAgIGxuZzogMTI2Ljg0MjcyNjk5NTEwMzdcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4NTg3MDI4ODA5MDgsXG4gICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICB9LFxuICAgICAgICBtYW5hZ2VySW5mbzoge1xuICAgICAgICAgICAgbmFtZTogXCJNaWtlIENoZW5cIixcbiAgICAgICAgICAgIHBob25lOiBcIis4Mi0xMC0yMzQ1LTY3ODlcIixcbiAgICAgICAgICAgIGRlcGFydG1lbnQ6IFwiRm9vZCBQcmVwYXJhdGlvblwiLFxuICAgICAgICAgICAgcm9sZTogXCJIZWFkIENoZWZcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMTowMDowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciByZWNlaXZlZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTE6MDU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiUHJlcGFyaW5nIHlvdXIgb3JkZXJcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJSZXN0YXVyYW50IEtpdGNoZW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICAzOiB7XG4gICAgICAgIG9yZGVySWQ6IDMsXG4gICAgICAgIHN0YXR1czogXCJvdXRfZm9yX2RlbGl2ZXJ5XCIsXG4gICAgICAgIGVzdGltYXRlZERlbGl2ZXJ5VGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ICogNjAgKiAxMDAwKSwgLy8gMTUgbWludXRlcyBmcm9tIG5vd1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI5MCxcbiAgICAgICAgICAgIGxuZzogMTI2Ljg0MjBcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4NTg3MDI4ODA5MDgsXG4gICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICB9LFxuICAgICAgICBtYW5hZ2VySW5mbzoge1xuICAgICAgICAgICAgbmFtZTogXCJFbW1hIERhdmlzXCIsXG4gICAgICAgICAgICBwaG9uZTogXCIrODItMTAtMzQ1Ni03ODkwXCIsXG4gICAgICAgICAgICBkZXBhcnRtZW50OiBcIkRlbGl2ZXJ5IE9wZXJhdGlvbnNcIixcbiAgICAgICAgICAgIHJvbGU6IFwiRGVsaXZlcnkgTWFuYWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDA5OjE1OjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIHJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiUmVzdGF1cmFudCBLaXRjaGVuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQwOTozMDowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciBwcmVwYXJlZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTVUMTE6NDU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3V0IGZvciBkZWxpdmVyeVwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIkVuIHJvdXRlIHRvIGN1c3RvbWVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgNDoge1xuICAgICAgICBvcmRlcklkOiA0LFxuICAgICAgICBzdGF0dXM6IFwiZGVsaXZlcmVkXCIsXG4gICAgICAgIGVzdGltYXRlZERlbGl2ZXJ5VGltZTogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTk6MTU6MDAnKSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgICBsYXQ6IDM1LjIyODU4NzAyODgwOTA4LFxuICAgICAgICAgICAgbG5nOiAxMjYuODM5MjIzNzA5NzI1NDNcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGxhdDogMzUuMjI4NTg3MDI4ODA5MDgsXG4gICAgICAgICAgICBsbmc6IDEyNi44MzkyMjM3MDk3MjU0M1xuICAgICAgICB9LFxuICAgICAgICBtYW5hZ2VySW5mbzoge1xuICAgICAgICAgICAgbmFtZTogXCJKYW1lcyBXaWxzb25cIixcbiAgICAgICAgICAgIHBob25lOiBcIis4Mi0xMC00NTY3LTg5MDFcIixcbiAgICAgICAgICAgIGRlcGFydG1lbnQ6IFwiQ3VzdG9tZXIgU2VydmljZVwiLFxuICAgICAgICAgICAgcm9sZTogXCJTZXJ2aWNlIE1hbmFnZXJcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNFQxODozMDowMCcpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJPcmRlciByZWNlaXZlZFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnQgS2l0Y2hlblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTg6NDU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgcHJlcGFyZWRcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJSZXN0YXVyYW50IEtpdGNoZW5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCcyMDI0LTAxLTE0VDE5OjAwOjAwJyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIk91dCBmb3IgZGVsaXZlcnlcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJFbiByb3V0ZSB0byBjdXN0b21lclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoJzIwMjQtMDEtMTRUMTk6MTU6MDAnKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiRGVsaXZlcmVkIHN1Y2Nlc3NmdWxseVwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIkN1c3RvbWVyIGxvY2F0aW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbn07XG5cbi8vIFNpbXVsYXRlIEFQSSBkZWxheVxuY29uc3QgZGVsYXkgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgb3JkZXIgaGFzIHByb3BlciBzdHJ1Y3R1cmVcbmNvbnN0IG5vcm1hbGl6ZU9yZGVyID0gKG9yZGVyOiBhbnkpOiBPcmRlciA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IG9yZGVyLmlkIHx8IDAsXG4gICAgICAgIHVzZXJJZDogb3JkZXIudXNlcklkIHx8IDAsXG4gICAgICAgIGl0ZW1zOiBBcnJheS5pc0FycmF5KG9yZGVyLml0ZW1zKSA/IG9yZGVyLml0ZW1zLm1hcCgoaXRlbTogYW55KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQgfHwgMCxcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSB8fCAnVW5rbm93biBJdGVtJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLmRlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICAgICAgcHJpY2U6IHR5cGVvZiBpdGVtLnByaWNlID09PSAnbnVtYmVyJyA/IGl0ZW0ucHJpY2UgOiAwLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnkgfHwgJ1Vua25vd24nLFxuICAgICAgICAgICAgaW1hZ2U6IGl0ZW0uaW1hZ2UgfHwgJycsXG4gICAgICAgICAgICBxdWFudGl0eTogdHlwZW9mIGl0ZW0ucXVhbnRpdHkgPT09ICdudW1iZXInID8gaXRlbS5xdWFudGl0eSA6IDFcbiAgICAgICAgfSkpIDogW10sXG4gICAgICAgIHRvdGFsQW1vdW50OiB0eXBlb2Ygb3JkZXIudG90YWxBbW91bnQgPT09ICdudW1iZXInID8gb3JkZXIudG90YWxBbW91bnQgOiAwLFxuICAgICAgICBzdGF0dXM6IG9yZGVyLnN0YXR1cyB8fCAncGVuZGluZycsXG4gICAgICAgIGNyZWF0ZWRBdDogb3JkZXIuY3JlYXRlZEF0ID8gbmV3IERhdGUob3JkZXIuY3JlYXRlZEF0KSA6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogb3JkZXIudXBkYXRlZEF0ID8gbmV3IERhdGUob3JkZXIudXBkYXRlZEF0KSA6IG5ldyBEYXRlKClcbiAgICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IG9yZGVyU2VydmljZSA9IHtcbiAgICAvLyBHZXQgYWxsIG9yZGVycyBmb3IgYSB1c2VyXG4gICAgYXN5bmMgZ2V0T3JkZXJzKHVzZXJJZD86IG51bWJlcik6IFByb21pc2U8T3JkZXJbXT4ge1xuICAgICAgICBhd2FpdCBkZWxheSg1MDApOyAvLyBTaW11bGF0ZSBBUEkgY2FsbCBkZWxheVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZE9yZGVycyA9IG1vY2tPcmRlcnM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZE9yZGVycyA9IG1vY2tPcmRlcnMuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnVzZXJJZCA9PT0gdXNlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFsbCBvcmRlcnMgdG8gZW5zdXJlIHByb3BlciBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZE9yZGVycy5tYXAobm9ybWFsaXplT3JkZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0T3JkZXJzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBzcGVjaWZpYyBvcmRlciBieSBJRFxuICAgIGFzeW5jIGdldE9yZGVyKG9yZGVySWQ6IG51bWJlcik6IFByb21pc2U8T3JkZXIgfCBudWxsPiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDMwMCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBtb2NrT3JkZXJzLmZpbmQob3JkZXIgPT4gb3JkZXIuaWQgPT09IG9yZGVySWQpO1xuICAgICAgICAgICAgcmV0dXJuIG9yZGVyID8gbm9ybWFsaXplT3JkZXIob3JkZXIpIDogbnVsbDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldE9yZGVyOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBkZWxpdmVyeSB0cmFja2luZyBpbmZvcm1hdGlvbiBmb3IgYW4gb3JkZXJcbiAgICBhc3luYyBnZXREZWxpdmVyeVRyYWNraW5nKG9yZGVySWQ6IG51bWJlcik6IFByb21pc2U8RGVsaXZlcnlUcmFja2luZyB8IG51bGw+IHtcbiAgICAgICAgYXdhaXQgZGVsYXkoNDAwKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZyA9IG1vY2tEZWxpdmVyeVRyYWNraW5nW29yZGVySWRdO1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNraW5nIHx8IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXREZWxpdmVyeVRyYWNraW5nOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBvcmRlclxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyKG9yZGVyRGF0YTogT21pdDxPcmRlciwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+KTogUHJvbWlzZTxPcmRlcj4ge1xuICAgICAgICBhd2FpdCBkZWxheSg2MDApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09yZGVyOiBPcmRlciA9IG5vcm1hbGl6ZU9yZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5vcmRlckRhdGEsXG4gICAgICAgICAgICAgICAgaWQ6IG1vY2tPcmRlcnMubGVuZ3RoICsgMSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja09yZGVycy5wdXNoKG5ld09yZGVyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgZGVsaXZlcnkgdHJhY2tpbmdcbiAgICAgICAgICAgIG1vY2tEZWxpdmVyeVRyYWNraW5nW25ld09yZGVyLmlkXSA9IHtcbiAgICAgICAgICAgICAgICBvcmRlcklkOiBuZXdPcmRlci5pZCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiY29uZmlybWVkXCIsXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkRGVsaXZlcnlUaW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNDUgKiA2MCAqIDEwMDApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBsYXQ6IDM1LjIyODk1MDYxOTAyOTA4NSxcbiAgICAgICAgICAgICAgICAgICAgbG5nOiAxMjYuODQyNzI2OTk1MTAzN1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgbGF0OiAzNS4yMjg1ODcwMjg4MDkwOCxcbiAgICAgICAgICAgICAgICAgICAgbG5nOiAxMjYuODM5MjIzNzA5NzI1NDNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1hbmFnZXJJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTmV3IE9yZGVyIE1hbmFnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgcGhvbmU6IFwiKzgyLTEwLTk5OTktMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXBhcnRtZW50OiBcIk9yZGVyIFByb2Nlc3NpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJPcmRlciBNYW5hZ2VyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIk9yZGVyIHJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJSZXN0YXVyYW50IEtpdGNoZW5cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ld09yZGVyO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlT3JkZXI6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIG9yZGVyJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIG9yZGVyIHN0YXR1c1xuICAgIGFzeW5jIHVwZGF0ZU9yZGVyU3RhdHVzKG9yZGVySWQ6IG51bWJlciwgc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPE9yZGVyIHwgbnVsbD4ge1xuICAgICAgICBhd2FpdCBkZWxheSgzMDApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVySW5kZXggPSBtb2NrT3JkZXJzLmZpbmRJbmRleChvcmRlciA9PiBvcmRlci5pZCA9PT0gb3JkZXJJZCk7XG4gICAgICAgICAgICBpZiAob3JkZXJJbmRleCA9PT0gLTEpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrT3JkZXJzW29yZGVySW5kZXhdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIG1vY2tPcmRlcnNbb3JkZXJJbmRleF0udXBkYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGRlbGl2ZXJ5IHRyYWNraW5nXG4gICAgICAgICAgICBpZiAobW9ja0RlbGl2ZXJ5VHJhY2tpbmdbb3JkZXJJZF0pIHtcbiAgICAgICAgICAgICAgICBtb2NrRGVsaXZlcnlUcmFja2luZ1tvcmRlcklkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgbW9ja0RlbGl2ZXJ5VHJhY2tpbmdbb3JkZXJJZF0udXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGBTdGF0dXMgdXBkYXRlZCB0byAke3N0YXR1c31gLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogc3RhdHVzID09PSBcImRlbGl2ZXJlZFwiID8gXCJDdXN0b21lciBsb2NhdGlvblwiIDogXCJJbiBwcm9ncmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVPcmRlcihtb2NrT3JkZXJzW29yZGVySW5kZXhdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVwZGF0ZU9yZGVyU3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbmNlbCBhbiBvcmRlclxuICAgIGFzeW5jIGNhbmNlbE9yZGVyKG9yZGVySWQ6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBhd2FpdCBkZWxheSg0MDApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVySW5kZXggPSBtb2NrT3JkZXJzLmZpbmRJbmRleChvcmRlciA9PiBvcmRlci5pZCA9PT0gb3JkZXJJZCk7XG4gICAgICAgICAgICBpZiAob3JkZXJJbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG1vY2tPcmRlcnNbb3JkZXJJbmRleF0uc3RhdHVzID09PSBcImRlbGl2ZXJlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBDYW5ub3QgY2FuY2VsIGRlbGl2ZXJlZCBvcmRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja09yZGVyc1tvcmRlckluZGV4XS5zdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgbW9ja09yZGVyc1tvcmRlckluZGV4XS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgZGVsaXZlcnkgdHJhY2tpbmdcbiAgICAgICAgICAgIGlmIChtb2NrRGVsaXZlcnlUcmFja2luZ1tvcmRlcklkXSkge1xuICAgICAgICAgICAgICAgIG1vY2tEZWxpdmVyeVRyYWNraW5nW29yZGVySWRdLnN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgbW9ja0RlbGl2ZXJ5VHJhY2tpbmdbb3JkZXJJZF0udXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiT3JkZXIgY2FuY2VsbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBcIlJlc3RhdXJhbnRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNhbmNlbE9yZGVyOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgb3JkZXIgc3RhdHVzIG9wdGlvbnNcbiAgICBnZXRPcmRlclN0YXR1c2VzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgXCJjb25maXJtZWRcIiwgXG4gICAgICAgICAgICBcInByZXBhcmluZ1wiLFxuICAgICAgICAgICAgXCJyZWFkeV9mb3JfcGlja3VwXCIsXG4gICAgICAgICAgICBcIm91dF9mb3JfZGVsaXZlcnlcIixcbiAgICAgICAgICAgIFwiZGVsaXZlcmVkXCIsXG4gICAgICAgICAgICBcImNhbmNlbGxlZFwiXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8vIFNlYXJjaCBvcmRlcnMgYnkgc3RhdHVzXG4gICAgYXN5bmMgZ2V0T3JkZXJzQnlTdGF0dXMoc3RhdHVzOiBzdHJpbmcsIHVzZXJJZD86IG51bWJlcik6IFByb21pc2U8T3JkZXJbXT4ge1xuICAgICAgICBhd2FpdCBkZWxheSgzMDApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZE9yZGVycyA9IG1vY2tPcmRlcnMuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnN0YXR1cyA9PT0gc3RhdHVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkT3JkZXJzID0gZmlsdGVyZWRPcmRlcnMuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnVzZXJJZCA9PT0gdXNlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkT3JkZXJzLm1hcChub3JtYWxpemVPcmRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRPcmRlcnNCeVN0YXR1czonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBFeHBvcnQgaW5kaXZpZHVhbCBmdW5jdGlvbnMgZm9yIG5hbWVkIGltcG9ydHNcbmV4cG9ydCBjb25zdCB7XG4gICAgZ2V0T3JkZXJzLFxuICAgIGdldE9yZGVyLFxuICAgIGdldERlbGl2ZXJ5VHJhY2tpbmcsXG4gICAgY3JlYXRlT3JkZXIsXG4gICAgdXBkYXRlT3JkZXJTdGF0dXMsXG4gICAgY2FuY2VsT3JkZXIsXG4gICAgZ2V0T3JkZXJTdGF0dXNlcyxcbiAgICBnZXRPcmRlcnNCeVN0YXR1c1xufSA9IG9yZGVyU2VydmljZTtcblxuLy8gRGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IG9yZGVyU2VydmljZTtcbiJdLCJuYW1lcyI6WyJtb2NrT3JkZXJzIiwiaWQiLCJ1c2VySWQiLCJpdGVtcyIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwiY2F0ZWdvcnkiLCJpbWFnZSIsInF1YW50aXR5IiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwibW9ja0RlbGl2ZXJ5VHJhY2tpbmciLCJvcmRlcklkIiwiZXN0aW1hdGVkRGVsaXZlcnlUaW1lIiwibm93IiwiY3VycmVudExvY2F0aW9uIiwibGF0IiwibG5nIiwiZGVzdGluYXRpb24iLCJtYW5hZ2VySW5mbyIsInBob25lIiwiZGVwYXJ0bWVudCIsInJvbGUiLCJ1cGRhdGVzIiwidGltZXN0YW1wIiwibG9jYXRpb24iLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwibm9ybWFsaXplT3JkZXIiLCJvcmRlciIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJvcmRlclNlcnZpY2UiLCJnZXRPcmRlcnMiLCJmaWx0ZXJlZE9yZGVycyIsImZpbHRlciIsImVycm9yIiwiY29uc29sZSIsImdldE9yZGVyIiwiZmluZCIsImdldERlbGl2ZXJ5VHJhY2tpbmciLCJ0cmFja2luZyIsImNyZWF0ZU9yZGVyIiwib3JkZXJEYXRhIiwibmV3T3JkZXIiLCJsZW5ndGgiLCJwdXNoIiwiRXJyb3IiLCJ1cGRhdGVPcmRlclN0YXR1cyIsIm9yZGVySW5kZXgiLCJmaW5kSW5kZXgiLCJjYW5jZWxPcmRlciIsImdldE9yZGVyU3RhdHVzZXMiLCJnZXRPcmRlcnNCeVN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/orderService.ts\n"));

/***/ })

});